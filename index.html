<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiobook Player</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { background-color: #111827; color: #f3f4f6; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        input[type=range] { accent-color: #3b82f6; }
    </style>
</head>
<body>

<div class="min-h-screen bg-gray-950 text-gray-100 flex flex-col">
    <header class="px-4 sm:px-6 py-4 border-b border-gray-800 bg-gray-950/95 backdrop-blur">
        <div class="flex flex-wrap items-center justify-between gap-3">
            <div>
                <h1 class="text-lg sm:text-xl font-bold text-blue-400">AudioLibrary</h1>
                <div class="text-xs text-gray-500">Version <span id="app-version"></span></div>
            </div>
            <div class="flex items-center gap-2 text-xs text-gray-400">
                <span class="uppercase tracking-wide text-gray-500">Source</span>
                <span class="px-2 py-1 rounded-full border border-gray-800 bg-gray-900/80">Local</span>
                <span class="px-2 py-1 rounded-full border border-emerald-800/60 bg-emerald-900/40 text-emerald-300" id="server-badge" hidden>Server Stream</span>
            </div>
        </div>
        <nav class="mt-4 hidden sm:flex items-center gap-2">
            <button class="screen-tab px-4 py-2 rounded-lg bg-gray-800 text-gray-300 text-sm font-medium" data-screen="library" aria-pressed="false">Library</button>
            <button class="screen-tab px-4 py-2 rounded-lg bg-gray-800 text-gray-300 text-sm font-medium" data-screen="player" aria-pressed="false">Player</button>
            <button class="screen-tab px-4 py-2 rounded-lg bg-gray-800 text-gray-300 text-sm font-medium" data-screen="settings" aria-pressed="false">Settings</button>
            <button class="screen-tab px-4 py-2 rounded-lg bg-gray-800 text-gray-300 text-sm font-medium" data-screen="logs" aria-pressed="false">Logs</button>
        </nav>
    </header>

    <main class="flex-1 overflow-y-auto pb-20 sm:pb-6">
        <section id="screen-library" class="screen-panel px-4 sm:px-6 py-6 space-y-5" data-screen-panel="library">
            <div class="rounded-2xl border border-gray-800 bg-gray-900/70 p-4 sm:p-5 space-y-4">
                <div class="flex flex-col gap-2">
                    <button
                        id="scan-server"
                        class="flex items-center justify-center w-full px-4 py-2.5 bg-emerald-700 hover:bg-emerald-600 text-white rounded-xl transition text-sm font-semibold"
                    >
                        Scan Server (./books)
                    </button>

                    <div class="flex items-center gap-2 my-1">
                        <div class="h-px bg-gray-700 flex-1"></div>
                        <span class="text-xs text-gray-500">OR</span>
                        <div class="h-px bg-gray-700 flex-1"></div>
                    </div>

                    <label class="flex items-center justify-center w-full px-4 py-2.5 bg-gray-700 hover:bg-gray-600 text-gray-200 rounded-xl cursor-pointer transition select-none text-sm font-semibold">
                        Browse Local Folder...
                        <input id="local-files" type="file" webkitdirectory="true" directory="" multiple class="hidden" />
                    </label>
                </div>
            </div>

            <div class="p-2 text-xs text-red-200" id="error-box" hidden></div>
            <div class="p-2 text-xs text-gray-400" id="loading" hidden>Scanning...</div>

            <div class="rounded-2xl border border-gray-800 bg-gray-900/40 p-2" id="library">
                <div class="text-gray-500 text-center mt-6 p-4 text-sm" id="empty-state">
                    <p>No books found yet.</p>
                    <p class="mt-2 text-xs opacity-60">
                        For Server Mode: Ensure a "books" folder exists next to this file and "Directory Listing" is enabled on your server.
                    </p>
                </div>
            </div>
        </section>

        <section id="screen-player" class="screen-panel hidden px-4 sm:px-6 py-6 space-y-6" data-screen-panel="player">
            <div class="rounded-3xl bg-gray-900/70 border border-gray-800 p-5 sm:p-6 flex flex-col items-center text-center gap-4">
                <div class="w-28 h-28 sm:w-40 sm:h-40 bg-gray-800 rounded-2xl shadow-2xl flex items-center justify-center border border-gray-700">
                    <span class="text-4xl sm:text-5xl">ðŸŽ§</span>
                </div>
                <div>
                    <h2 class="text-lg sm:text-2xl font-bold text-white mb-2 max-w-2xl truncate px-4" id="track-title">No Track Selected</h2>
                    <h3 class="text-sm sm:text-lg text-gray-400 px-4" id="book-title">Select a book to start</h3>
                </div>
            </div>

            <section class="rounded-3xl bg-gray-900 border border-gray-800 p-4 sm:p-6 pb-6 sm:pb-8 space-y-4">
                <div class="flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4 text-sm text-gray-400 font-mono">
                    <span class="w-12 text-right" id="current-time">00:00</span>
                    <input
                        id="seek-bar"
                        type="range"
                        min="0"
                        max="0"
                        value="0"
                        class="flex-1 h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                    />
                    <span class="w-12" id="duration">00:00</span>
                </div>

                <div>
                    <audio id="audio-player" controls class="w-full"></audio>
                </div>
            </section>
        </section>

        <section id="screen-settings" class="screen-panel hidden px-4 sm:px-6 py-6 space-y-5" data-screen-panel="settings">
            <div class="rounded-2xl border border-gray-800 bg-gray-900/70 p-4 sm:p-5 space-y-3">
                <h2 class="text-sm uppercase tracking-wide text-gray-500">Playback &amp; Sleep</h2>
                <p class="text-sm text-gray-400">Control sleep timers and playback habits from here.</p>
                <div class="flex flex-wrap items-center gap-2 text-xs text-gray-400">
                    <span class="uppercase tracking-wide text-gray-500">Sleep Timer</span>
                    <button id="sleep-15" class="px-3 py-1.5 rounded-lg bg-gray-800 hover:bg-gray-700 text-gray-200">15 min</button>
                    <button id="sleep-30" class="px-3 py-1.5 rounded-lg bg-gray-800 hover:bg-gray-700 text-gray-200">30 min</button>
                    <button id="sleep-cancel" class="px-3 py-1.5 rounded-lg bg-gray-800 hover:bg-gray-700 text-gray-200" disabled>Cancel</button>
                    <span id="sleep-status" class="text-gray-500"></span>
                </div>
            </div>
            <div class="rounded-2xl border border-gray-800 bg-gray-900/40 p-4 sm:p-5 space-y-2 text-sm text-gray-400">
                <h2 class="text-sm uppercase tracking-wide text-gray-500">About</h2>
                <p>Your playback position is saved on this device so you can resume where you left off.</p>
                <p>Use the Library screen to scan a server or browse local folders.</p>
            </div>
        </section>

        <section id="screen-logs" class="screen-panel hidden px-4 sm:px-6 py-6" data-screen-panel="logs">
            <div class="rounded-2xl border border-gray-800 bg-gray-900/70 p-4 sm:p-5 text-xs text-gray-400">
                <div class="flex items-center justify-between mb-3">
                    <span class="uppercase tracking-wide text-gray-500">Diagnostics</span>
                    <div class="flex items-center gap-3">
                        <button id="toggle-logs" class="text-xs text-gray-500 hover:text-gray-300">Hide Logs</button>
                        <button id="clear-log" class="text-xs text-gray-500 hover:text-gray-300">Clear</button>
                    </div>
                </div>
                <div id="diagnostics-content" class="max-h-60 overflow-y-auto">
                    <div id="diagnostics-empty" class="text-gray-600">No diagnostics yet. Click a track to capture logs.</div>
                    <ul id="diagnostics-list" class="space-y-1 font-mono"></ul>
                </div>
            </div>
        </section>
    </main>

    <nav class="fixed bottom-0 left-0 right-0 bg-gray-950/95 border-t border-gray-800 px-4 py-3 flex items-center justify-between gap-2 text-xs sm:hidden">
        <button class="screen-tab flex-1 py-2 rounded-xl bg-gray-800 text-gray-300 font-semibold" data-screen="library" aria-pressed="false">Library</button>
        <button class="screen-tab flex-1 py-2 rounded-xl bg-gray-800 text-gray-300 font-semibold" data-screen="player" aria-pressed="false">Player</button>
        <button class="screen-tab flex-1 py-2 rounded-xl bg-gray-800 text-gray-300 font-semibold" data-screen="settings" aria-pressed="false">Settings</button>
        <button class="screen-tab flex-1 py-2 rounded-xl bg-gray-800 text-gray-300 font-semibold" data-screen="logs" aria-pressed="false">Logs</button>
    </nav>
</div>

<script>
    const APP_VERSION = "1.0.9";

    const state = {
        books: {},
        currentBook: null,
        currentTrackIndex: -1,
        sourceMode: 'none',
        log: [],
        playbackPositions: {},
        currentTrackKey: null,
        lastSavedPosition: 0,
        autoPlayRequested: false,
        pendingResumePosition: null,
        isRestoringPosition: false,
        sleepTimerId: null,
        sleepTimerInterval: null,
        sleepTimerEndsAt: null,
        logsVisible: true,
        activeScreen: 'library',
    };

    const elements = {
        appVersion: document.getElementById('app-version'),
        scanServer: document.getElementById('scan-server'),
        localFiles: document.getElementById('local-files'),
        errorBox: document.getElementById('error-box'),
        loading: document.getElementById('loading'),
        library: document.getElementById('library'),
        emptyState: document.getElementById('empty-state'),
        trackTitle: document.getElementById('track-title'),
        bookTitle: document.getElementById('book-title'),
        serverBadge: document.getElementById('server-badge'),
        audio: document.getElementById('audio-player'),
        currentTime: document.getElementById('current-time'),
        duration: document.getElementById('duration'),
        seekBar: document.getElementById('seek-bar'),
        diagnosticsList: document.getElementById('diagnostics-list'),
        diagnosticsEmpty: document.getElementById('diagnostics-empty'),
        clearLog: document.getElementById('clear-log'),
        toggleLogs: document.getElementById('toggle-logs'),
        diagnosticsContent: document.getElementById('diagnostics-content'),
        sleep15: document.getElementById('sleep-15'),
        sleep30: document.getElementById('sleep-30'),
        sleepCancel: document.getElementById('sleep-cancel'),
        sleepStatus: document.getElementById('sleep-status'),
        screenButtons: document.querySelectorAll('.screen-tab'),
        screenPanels: document.querySelectorAll('.screen-panel'),
    };

    elements.appVersion.textContent = APP_VERSION;

    const PLAYBACK_STORAGE_KEY = 'audiobookPlayer.playbackPositions';

    const loadPlaybackPositions = () => {
        try {
            const stored = localStorage.getItem(PLAYBACK_STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        } catch (err) {
            appendLog(`Failed to load playback positions: ${err.message || err}`);
            return {};
        }
    };

    const savePlaybackPositions = () => {
        try {
            localStorage.setItem(PLAYBACK_STORAGE_KEY, JSON.stringify(state.playbackPositions));
        } catch (err) {
            appendLog(`Failed to save playback positions: ${err.message || err}`);
        }
    };

    const formatTime = (seconds) => {
        if (!seconds || Number.isNaN(seconds)) return "00:00";
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        const mStr = m.toString().padStart(2, '0');
        const sStr = s.toString().padStart(2, '0');
        return h > 0 ? `${h}:${mStr}:${sStr}` : `${mStr}:${sStr}`;
    };

    const appendLog = (message) => {
        const timestamp = new Date().toLocaleTimeString();
        const line = `[${timestamp}] ${message}`;
        state.log = [...state.log.slice(-99), line];
        elements.diagnosticsList.innerHTML = state.log.map(entry => `<li>${entry}</li>`).join('');
        elements.diagnosticsEmpty.hidden = state.log.length > 0;
        console.log(line);
    };

    const updateDiagnosticsVisibility = () => {
        elements.diagnosticsContent.hidden = !state.logsVisible;
        elements.toggleLogs.textContent = state.logsVisible ? 'Hide Logs' : 'Show Logs';
    };

    const setActiveScreen = (screen) => {
        state.activeScreen = screen;
        elements.screenPanels.forEach(panel => {
            panel.hidden = panel.dataset.screenPanel !== screen;
        });
        elements.screenButtons.forEach(button => {
            const isActive = button.dataset.screen === screen;
            button.classList.toggle('bg-blue-600', isActive);
            button.classList.toggle('text-white', isActive);
            button.classList.toggle('bg-gray-800', !isActive);
            button.classList.toggle('text-gray-300', !isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
    };

    const setError = (message) => {
        if (!message) {
            elements.errorBox.hidden = true;
            elements.errorBox.textContent = "";
            return;
        }
        elements.errorBox.hidden = false;
        elements.errorBox.textContent = message;
    };

    const setLoading = (isLoading) => {
        elements.loading.hidden = !isLoading;
    };

    const buildTrackKey = (bookName, track) => {
        if (state.sourceMode === 'server' && track.url) {
            return `server:${track.url}`;
        }
        if (track.file?.webkitRelativePath) {
            return `local:${track.file.webkitRelativePath}`;
        }
        if (track.file && typeof track.file.size === 'number') {
            return `local:${bookName}:${track.file.name}:${track.file.size}`;
        }
        return `local:${bookName}:${track.name}`;
    };

    const persistCurrentPlayback = () => {
        if (!state.currentTrackKey) return;
        const currentTime = elements.audio.currentTime;
        if (!Number.isNaN(currentTime)) {
            state.playbackPositions[state.currentTrackKey] = currentTime;
            state.lastSavedPosition = currentTime;
            savePlaybackPositions();
            appendLog(`Saved position at ${formatTime(currentTime)}.`);
        }
    };

    const updateSleepStatus = () => {
        if (!state.sleepTimerEndsAt) {
            elements.sleepStatus.textContent = '';
            return;
        }
        const remainingMs = Math.max(0, state.sleepTimerEndsAt - Date.now());
        const remainingSeconds = Math.ceil(remainingMs / 1000);
        elements.sleepStatus.textContent = `Ends in ${formatTime(remainingSeconds)}`;
    };

    const clearSleepTimer = () => {
        if (state.sleepTimerId) {
            clearTimeout(state.sleepTimerId);
        }
        if (state.sleepTimerInterval) {
            clearInterval(state.sleepTimerInterval);
        }
        state.sleepTimerId = null;
        state.sleepTimerInterval = null;
        state.sleepTimerEndsAt = null;
        elements.sleepCancel.disabled = true;
        updateSleepStatus();
    };

    const setSleepTimer = (minutes) => {
        clearSleepTimer();
        const durationMs = minutes * 60 * 1000;
        state.sleepTimerEndsAt = Date.now() + durationMs;
        elements.sleepCancel.disabled = false;
        updateSleepStatus();
        state.sleepTimerInterval = setInterval(updateSleepStatus, 1000);
        state.sleepTimerId = setTimeout(() => {
            elements.audio.pause();
            appendLog('Sleep timer paused playback.');
            appendLog(`Sleep timer ended after ${minutes} minutes.`);
            clearSleepTimer();
        }, durationMs);
        appendLog(`Sleep timer set for ${minutes} minutes.`);
    };

    const renderLibrary = () => {
        const bookNames = Object.keys(state.books);
        elements.library.innerHTML = '';
        if (bookNames.length === 0) {
            elements.library.appendChild(elements.emptyState);
            return;
        }

        elements.emptyState.remove();
        bookNames.forEach(bookName => {
            const wrapper = document.createElement('div');
            wrapper.className = 'mb-4';

            const header = document.createElement('h2');
            header.className = 'text-gray-400 text-sm uppercase font-bold px-2 mb-1 sticky top-0 bg-gray-900 py-1 z-10 border-b border-gray-800/50 flex justify-between';
            header.innerHTML = `<span class="truncate">${bookName}</span><span class="text-xs opacity-50 font-normal ml-2 mt-0.5">${state.books[bookName].length}</span>`;
            wrapper.appendChild(header);

            const list = document.createElement('div');
            list.className = 'space-y-1';

            state.books[bookName].forEach((track, idx) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'w-full text-left px-3 py-2 text-sm rounded truncate flex items-center gap-2 transition hover:bg-gray-800 text-gray-300';
                button.textContent = track.name;
                button.addEventListener('click', () => playTrack(bookName, idx));
                list.appendChild(button);
            });

            wrapper.appendChild(list);
            elements.library.appendChild(wrapper);
        });
    };

    const parseDirectoryListing = async (path) => {
        const targetPath = path.endsWith('/') ? path : `${path}/`;
        const response = await fetch(targetPath);
        if (!response.ok) throw new Error(`Failed to fetch ${targetPath}`);
        const text = await response.text();

        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');
        const links = Array.from(doc.querySelectorAll('a'));

        return links
            .map(link => link.getAttribute('href'))
            .filter(href => href && href !== '../' && href !== './' && !href.startsWith('?'))
            .map(href => ({
                href,
                fullPath: new URL(href, new URL(targetPath, window.location.href)).toString(),
            }));
    };

    const scanServer = async () => {
        setLoading(true);
        setError(null);
        state.books = {};
        appendLog('Scanning server for books...');
        try {
            const rootPath = './books/';
            const topLevelItems = await parseDirectoryListing(rootPath);
            if (topLevelItems.length === 0) {
                throw new Error('Could not find any files in ./books. Ensure the folder exists and Directory Listing is enabled.');
            }

            const newBooks = {};
            for (const item of topLevelItems) {
                if (item.href.endsWith('/')) {
                    const bookName = decodeURIComponent(item.href.replace(/\/$/, ''));
                    const chapters = await parseDirectoryListing(item.fullPath);
                    const tracks = chapters
                        .filter(ch => ch.href.toLowerCase().endsWith('.mp3'))
                        .map(ch => ({
                            name: decodeURIComponent(ch.href),
                            url: ch.fullPath,
                        }))
                        .sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

                    if (tracks.length > 0) {
                        newBooks[bookName] = tracks;
                        appendLog(`Found ${tracks.length} tracks in ${bookName}`);
                    }
                } else if (item.href.toLowerCase().endsWith('.mp3')) {
                    if (!newBooks['Root Directory']) newBooks['Root Directory'] = [];
                    newBooks['Root Directory'].push({
                        name: decodeURIComponent(item.href),
                        url: item.fullPath,
                    });
                    appendLog(`Found loose track ${decodeURIComponent(item.href)}`);
                }
            }

            if (Object.keys(newBooks).length === 0) {
                throw new Error('Found folders, but no MP3 files inside them.');
            }

            state.books = newBooks;
            state.sourceMode = 'server';
            elements.serverBadge.hidden = false;
            renderLibrary();
        } catch (err) {
            setError(err.message || 'Failed to scan server.');
            appendLog(`Server scan error: ${err.message || err}`);
        } finally {
            setLoading(false);
        }
    };

    const handleFileSelect = (event) => {
        setError(null);
        setLoading(true);
        try {
            const files = Array.from(event.target.files || []).filter(file => file.name.toLowerCase().endsWith('.mp3'));
            if (files.length === 0) {
                setError('No MP3 files found in the selected folder.');
                return;
            }

            const bookMap = {};
            files.forEach(file => {
                const parts = file.webkitRelativePath.split('/');
                const bookName = parts.length > 1 ? parts[parts.length - 2] : 'Root Directory';
                if (!bookMap[bookName]) bookMap[bookName] = [];
                bookMap[bookName].push({
                    name: file.name,
                    file,
                    url: URL.createObjectURL(file),
                });
            });

            Object.keys(bookMap).forEach(key => {
                bookMap[key].sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
            });

            state.books = bookMap;
            state.sourceMode = 'local';
            elements.serverBadge.hidden = true;
            renderLibrary();
            appendLog(`Loaded local files. Books: ${Object.keys(bookMap).length}`);
        } catch (err) {
            setError('Failed to load files.');
            appendLog(`Local file load error: ${err.message || err}`);
        } finally {
            setLoading(false);
        }
    };

    const resumeFromSavedPosition = () => {
        if (!state.currentTrackKey) return false;
        const savedPosition = state.playbackPositions[state.currentTrackKey];
        if (savedPosition && savedPosition < elements.audio.duration - 1) {
            elements.audio.currentTime = savedPosition;
            elements.seekBar.value = savedPosition;
            elements.currentTime.textContent = formatTime(savedPosition);
            appendLog(`Resuming at ${formatTime(savedPosition)}.`);
            return true;
        }
        return false;
    };

    const applyResumeAndMaybePlay = () => {
        const didResume = resumeFromSavedPosition();
        state.pendingResumePosition = didResume ? elements.audio.currentTime : 0;
        state.isRestoringPosition = false;
        if (state.autoPlayRequested) {
            state.autoPlayRequested = false;
            elements.audio.play().catch(err => {
                appendLog(`Playback failed: ${err.message || err}`);
                setError('Playback failed to start. Please try again.');
            });
        }
    };

    const playTrack = (bookName, index) => {
        const tracks = state.books[bookName];
        if (!tracks || !tracks[index]) return;

        persistCurrentPlayback();

        const track = tracks[index];
        const nextTrackKey = buildTrackKey(bookName, track);
        const isSameTrack = state.currentTrackKey === nextTrackKey && elements.audio.src === track.url;

        state.currentBook = bookName;
        state.currentTrackIndex = index;
        state.currentTrackKey = nextTrackKey;
        state.lastSavedPosition = state.playbackPositions[state.currentTrackKey] || 0;

        elements.trackTitle.textContent = track.name;
        elements.bookTitle.textContent = bookName;

        state.autoPlayRequested = true;
        state.pendingResumePosition = state.lastSavedPosition || 0;
        state.isRestoringPosition = true;
        if (state.lastSavedPosition) {
            appendLog(`Found saved position at ${formatTime(state.lastSavedPosition)} for ${bookName} / ${track.name}.`);
        } else {
            appendLog(`No saved position for ${bookName} / ${track.name}.`);
        }

        if (!isSameTrack) {
            elements.audio.src = track.url;
            appendLog(`Playing ${bookName} / ${track.name}`);
        } else {
            appendLog(`Resuming ${bookName} / ${track.name}`);
            if (elements.audio.readyState >= 1) {
                applyResumeAndMaybePlay();
            }
        }
        setActiveScreen('player');
    };

    elements.scanServer.addEventListener('click', scanServer);
    elements.localFiles.addEventListener('change', handleFileSelect);
    elements.sleep15.addEventListener('click', () => setSleepTimer(15));
    elements.sleep30.addEventListener('click', () => setSleepTimer(30));
    elements.sleepCancel.addEventListener('click', clearSleepTimer);
    elements.clearLog.addEventListener('click', () => {
        state.log = [];
        elements.diagnosticsList.innerHTML = '';
        elements.diagnosticsEmpty.hidden = false;
    });
    elements.toggleLogs.addEventListener('click', () => {
        state.logsVisible = !state.logsVisible;
        updateDiagnosticsVisibility();
    });
    elements.screenButtons.forEach(button => {
        button.addEventListener('click', () => {
            setActiveScreen(button.dataset.screen);
        });
    });

    elements.audio.addEventListener('timeupdate', () => {
        elements.currentTime.textContent = formatTime(elements.audio.currentTime);
        elements.seekBar.value = elements.audio.currentTime;
        if (state.currentTrackKey && !state.isRestoringPosition) {
            const currentTime = elements.audio.currentTime;
            if (Math.abs(currentTime - state.lastSavedPosition) >= 5) {
                state.playbackPositions[state.currentTrackKey] = currentTime;
                state.lastSavedPosition = currentTime;
                savePlaybackPositions();
            }
        }
    });

    elements.audio.addEventListener('loadedmetadata', () => {
        elements.duration.textContent = formatTime(elements.audio.duration);
        elements.seekBar.max = elements.audio.duration || 0;
        applyResumeAndMaybePlay();
    });

    elements.seekBar.addEventListener('input', (event) => {
        const nextTime = Number(event.target.value);
        if (!Number.isNaN(nextTime)) {
            elements.audio.currentTime = nextTime;
        }
    });

    elements.audio.addEventListener('pause', () => {
        appendLog('Playback paused. Saving position...');
        persistCurrentPlayback();
    });

    elements.audio.addEventListener('ended', () => {
        if (state.currentTrackKey) {
            state.playbackPositions[state.currentTrackKey] = 0;
            state.lastSavedPosition = 0;
            savePlaybackPositions();
        }
    });

    window.addEventListener('error', event => {
        appendLog(`Window error: ${event.message || 'unknown'}`);
    });

    window.addEventListener('unhandledrejection', event => {
        appendLog(`Unhandled rejection: ${event.reason?.message || event.reason || 'unknown'}`);
    });

    state.playbackPositions = loadPlaybackPositions();
    updateDiagnosticsVisibility();
    setActiveScreen(state.activeScreen);

    fetch('./books', { method: 'HEAD' })
        .then(res => { if (res.ok) scanServer(); })
        .catch(() => {});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiobook Player</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body { background-color: #111827; color: #f3f4f6; }
        /* Custom Scrollbar for list */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        input[type=range] {
            accent-color: #3b82f6;
        }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

    const { useState, useEffect, useRef, useMemo } = React;

    // --- Components ---

    const Icon = ({ name, size = 24, className = "" }) => {
        const iconRef = useRef(null);
        
        useEffect(() => {
            if (window.lucide && iconRef.current) {
                window.lucide.createIcons({
                    root: iconRef.current.parentNode,
                    nameAttr: 'data-lucide',
                    attrs: {
                        class: `lucide lucide-${name} ${className}`,
                        width: size,
                        height: size
                    }
                });
            }
        }, [name, className, size]);

        return <i ref={iconRef} data-lucide={name} className={className}></i>;
    };

    const formatTime = (seconds) => {
        if (!seconds || isNaN(seconds)) return "00:00";
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        
        const mStr = m.toString().padStart(2, '0');
        const sStr = s.toString().padStart(2, '0');
        
        return h > 0 ? `${h}:${mStr}:${sStr}` : `${mStr}:${sStr}`;
    };

    const APP_VERSION = "1.0.2";

    const App = () => {
        // --- State ---
        // books structure: { "BookName": [ { name: "Chapter.mp3", url: "...", file: FileObj (opt) } ] }
        const [books, setBooks] = useState({}); 
        const [currentBook, setCurrentBook] = useState(null);
        const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);
        const [isPlaying, setIsPlaying] = useState(false);
        const [currentTime, setCurrentTime] = useState(0);
        const [duration, setDuration] = useState(0);
        const [sleepTimer, setSleepTimer] = useState(null); 
        const [sleepTimerActive, setSleepTimerActive] = useState(false);
        const [playbackRate, setPlaybackRate] = useState(1.0);
        const [error, setError] = useState(null);
        const [loading, setLoading] = useState(false);
        const [sourceMode, setSourceMode] = useState('none'); // 'server', 'local', 'none'
        const [debugLog, setDebugLog] = useState([]);

        const audioRef = useRef(null);
        const timerRef = useRef(null);
        const saveIntervalRef = useRef(null);
        const storageAvailableRef = useRef(true);

        // --- Server Scanning Logic ---

        const parseDirectoryListing = async (path) => {
            try {
                const response = await fetch(path);
                if (!response.ok) throw new Error(`Failed to fetch ${path}`);
                const text = await response.text();
                
                // Parse HTML to find links
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/html');
                const links = Array.from(doc.querySelectorAll('a'));
                
                const items = [];
                for (const link of links) {
                    const href = link.getAttribute('href');
                    if (!href || href === '../' || href === './' || href.startsWith('?')) continue;
                    
                    // Decode URL encoded characters (e.g. %20 -> space)
                    const decodedHref = decodeURIComponent(href);
                    items.push({ href: decodedHref, fullPath: `${path}/${href}`.replace(/\/\//g, '/') });
                }
                return items;
            } catch (e) {
                console.warn("Directory parsing failed for", path, e);
                return [];
            }
        };

        const appendDebug = (message) => {
            const timestamp = new Date().toLocaleTimeString();
            const line = `[${timestamp}] ${message}`;
            setDebugLog(prev => [...prev.slice(-99), line]);
            console.log(line);
        };

        const safeStorageGet = (key) => {
            if (!storageAvailableRef.current) return null;
            try {
                return localStorage.getItem(key);
            } catch (e) {
                storageAvailableRef.current = false;
                appendDebug(`LocalStorage read blocked: ${e.message || e}`);
                return null;
            }
        };

        const safeStorageSet = (key, value) => {
            if (!storageAvailableRef.current) return;
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                storageAvailableRef.current = false;
                appendDebug(`LocalStorage write blocked: ${e.message || e}`);
            }
        };

        const scanServer = async () => {
            setLoading(true);
            setError(null);
            setBooks({});
            appendDebug("Scanning server for books...");
            
            try {
                const rootPath = './books';
                const topLevelItems = await parseDirectoryListing(rootPath);
                
                if (topLevelItems.length === 0) {
                    throw new Error("Could not find any files in ./books. Ensure the folder exists and Directory Listing is enabled in lighttpd.");
                }

                const newBooks = {};
                let foundAny = false;

                // We assume top level items are Folders (Books) or loose MP3s
                for (const item of topLevelItems) {
                    if (item.href.endsWith('/')) {
                        // It's a folder (Book)
                        const bookName = item.href.replace(/\/$/, '');
                        const chapters = await parseDirectoryListing(item.fullPath);
                        
                        const tracks = chapters
                            .filter(ch => ch.href.toLowerCase().endsWith('.mp3'))
                            .map(ch => ({
                                name: ch.href,
                                url: ch.fullPath,
                                size: 0 // Size unknown in server mode without HEAD request, used for unique ID
                            }))
                            .sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                        
                        if (tracks.length > 0) {
                            newBooks[bookName] = tracks;
                            foundAny = true;
                            appendDebug(`Found ${tracks.length} tracks in ${bookName}`);
                        }
                    } else if (item.href.toLowerCase().endsWith('.mp3')) {
                        // Loose file in root
                        if (!newBooks['Root Directory']) newBooks['Root Directory'] = [];
                        newBooks['Root Directory'].push({
                            name: item.href,
                            url: item.fullPath,
                            size: 0
                        });
                        foundAny = true;
                        appendDebug(`Found loose track ${item.href}`);
                    }
                }

                if (!foundAny) {
                    throw new Error("Found folders, but no MP3 files inside them.");
                }

                setBooks(newBooks);
                setSourceMode('server');
                appendDebug(`Server scan complete. Books: ${Object.keys(newBooks).length}`);

            } catch (err) {
                console.error(err);
                setError(err.message);
                appendDebug(`Server scan error: ${err.message}`);
            } finally {
                setLoading(false);
            }
        };

        // --- Local File Logic ---

        const handleFileSelect = (e) => {
            setError(null);
            setLoading(true);
            try {
                if (!e.target.files || e.target.files.length === 0) return;

                const rawFiles = Array.from(e.target.files).filter(f => f.name.toLowerCase().endsWith('.mp3'));
                
                if (rawFiles.length === 0) {
                    setError("No MP3 files found in the selected folder.");
                    setLoading(false);
                    return;
                }

                const bookMap = {};
                rawFiles.forEach(file => {
                    const pathParts = file.webkitRelativePath.split('/');
                    let bookName = "Root Directory";
                    if (pathParts.length > 1) {
                         bookName = pathParts[pathParts.length - 2];
                    }
                    
                    if (!bookMap[bookName]) bookMap[bookName] = [];
                    bookMap[bookName].push({
                        name: file.name,
                        file: file, // Store the File object
                        size: file.size
                    });
                });

                Object.keys(bookMap).forEach(key => {
                    bookMap[key].sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                });

                setBooks(bookMap);
                setSourceMode('local');
                appendDebug(`Loaded local files. Books: ${Object.keys(bookMap).length}`);
            } catch (err) {
                console.error("Error loading files:", err);
                setError("Failed to load files.");
                appendDebug("Local file load error.");
            } finally {
                setLoading(false);
            }
        };

        // --- Playback Logic ---

        const attemptPlay = (audioElement) => {
            if (!audioElement) return;
            try {
                const playPromise = audioElement.play();
                if (playPromise && typeof playPromise.catch === 'function') {
                    playPromise.catch(e => {
                        console.log("Play auto-start prevented", e);
                        setIsPlaying(false);
                        setError("Playback was blocked by the browser. Try clicking play again.");
                        appendDebug(`Playback blocked: ${e.message || e}`);
                    });
                }
            } catch (e) {
                console.error("Audio play failed", e);
                setIsPlaying(false);
                setError("Playback failed to start. Please try again.");
                appendDebug(`Playback failed: ${e.message || e}`);
            }
        };

        const playTrack = (bookName, index) => {
            try {
                if (!books[bookName] || !books[bookName][index]) return;

                const track = books[bookName][index];
                
                // Determine Source URL
                let src = "";
                if (track.file) {
                    src = URL.createObjectURL(track.file);
                } else if (track.url) {
                    src = track.url;
                }
                appendDebug(`Attempting to play ${bookName} / ${track.name} from ${src}`);

                // Unique ID for storage
                // In server mode size is 0, so we rely on book+name. In local mode we add size for robustness.
                const storageKey = `ab_pos_${bookName}_${track.name}_${track.size}`; 

                setCurrentBook(bookName);
                setCurrentTrackIndex(index);
                setIsPlaying(true);
                
                if (audioRef.current) {
                    audioRef.current.src = src;
                    audioRef.current.load();
                    appendDebug(`Audio src set. readyState=${audioRef.current.readyState}`);
                    
                    // Restore Position
                    const savedPos = safeStorageGet(storageKey);
                    if (savedPos) {
                        const pos = parseFloat(savedPos);
                        if (!isNaN(pos)) {
                            audioRef.current.currentTime = pos;
                        }
                    }

                    audioRef.current.playbackRate = playbackRate;
                    attemptPlay(audioRef.current);
                }
            } catch (err) {
                console.error("Error playing track:", err);
                setError(`Could not play track. ${err.message}`);
                appendDebug(`Play track error: ${err.message}`);
            }
        };

        // --- Effects ---

        // Auto-scan on load (optional, but good for UX)
        useEffect(() => {
            // Check if we can access ./books
            fetch('./books', { method: 'HEAD' })
                .then(res => {
                    if (res.ok) scanServer();
                })
                .catch(() => {
                    // Start in none mode, waiting for user
                });
        }, []);

        useEffect(() => {
            const onError = (event) => {
                appendDebug(`Window error: ${event.message || "unknown error"}`);
            };
            const onUnhandled = (event) => {
                appendDebug(`Unhandled rejection: ${event.reason?.message || event.reason || "unknown"}`);
            };
            window.addEventListener('error', onError);
            window.addEventListener('unhandledrejection', onUnhandled);
            return () => {
                window.removeEventListener('error', onError);
                window.removeEventListener('unhandledrejection', onUnhandled);
            };
        }, []);

        useEffect(() => {
            const audio = audioRef.current;
            if(!audio) return;

            const updateTime = () => setCurrentTime(audio.currentTime);
            const updateDuration = () => setDuration(audio.duration);
            const onEnded = () => {
                appendDebug("Track ended.");
                if (currentBook && books[currentBook] && currentTrackIndex < books[currentBook].length - 1) {
                    playTrack(currentBook, currentTrackIndex + 1);
                } else {
                    setIsPlaying(false);
                }
            };
            const onError = (e) => {
                console.error("Audio error", e); 
                setIsPlaying(false);
                setError("Audio failed to load. Check that the file exists and is playable.");
                appendDebug(`Audio error event. code=${audio?.error?.code || "unknown"}`);
            };
            const onCanPlay = () => appendDebug("Audio canplay event fired.");
            const onPlay = () => appendDebug("Audio play event fired.");
            const onPause = () => appendDebug("Audio pause event fired.");

            audio.addEventListener('timeupdate', updateTime);
            audio.addEventListener('loadedmetadata', updateDuration);
            audio.addEventListener('ended', onEnded);
            audio.addEventListener('error', onError);
            audio.addEventListener('canplay', onCanPlay);
            audio.addEventListener('play', onPlay);
            audio.addEventListener('pause', onPause);

            return () => {
                audio.removeEventListener('timeupdate', updateTime);
                audio.removeEventListener('loadedmetadata', updateDuration);
                audio.removeEventListener('ended', onEnded);
                audio.removeEventListener('error', onError);
                audio.removeEventListener('canplay', onCanPlay);
                audio.removeEventListener('play', onPlay);
                audio.removeEventListener('pause', onPause);
            };
        }, [currentBook, currentTrackIndex, books]);

        // Persistence
        useEffect(() => {
            saveIntervalRef.current = setInterval(() => {
                if (isPlaying && currentBook && books[currentBook]) {
                    const track = books[currentBook][currentTrackIndex];
                    if (track && audioRef.current) {
                        const storageKey = `ab_pos_${currentBook}_${track.name}_${track.size}`; 
                        safeStorageSet(storageKey, audioRef.current.currentTime);
                    }
                }
            }, 2000);
            return () => clearInterval(saveIntervalRef.current);
        }, [isPlaying, currentBook, currentTrackIndex, books]);

        // Sleep Timer
        useEffect(() => {
            if (sleepTimerActive && sleepTimer > 0 && isPlaying) {
                timerRef.current = setTimeout(() => {
                    setSleepTimer(prev => prev - 1000);
                }, 1000);
            } else if (sleepTimerActive && sleepTimer <= 0) {
                audioRef.current.pause();
                setIsPlaying(false);
                setSleepTimerActive(false);
                setSleepTimer(null);
            }
            return () => clearTimeout(timerRef.current);
        }, [sleepTimer, sleepTimerActive, isPlaying]);


        // --- UI Handlers ---
        const togglePlay = () => {
            if(!audioRef.current) return;
            if (audioRef.current.paused) {
                attemptPlay(audioRef.current);
                setIsPlaying(true);
            } else {
                audioRef.current.pause();
                setIsPlaying(false);
            }
        };

        const skip = (seconds) => {
            if(audioRef.current) audioRef.current.currentTime += seconds;
        };

        const activateSleepTimer = (minutes) => {
            setSleepTimer(minutes * 60 * 1000);
            setSleepTimerActive(true);
        };

        const cancelSleepTimer = () => {
            setSleepTimerActive(false);
            setSleepTimer(null);
        };

        const handleSeek = (e) => {
            if(!audioRef.current) return;
            const time = parseFloat(e.target.value);
            audioRef.current.currentTime = time;
            setCurrentTime(time);
        };

        const currentTrackName = useMemo(() => {
            if (!currentBook || !books[currentBook] || currentTrackIndex === -1) return "No Track Selected";
            return books[currentBook][currentTrackIndex].name;
        }, [currentBook, currentTrackIndex, books]);

        return (
            <div className="flex h-screen overflow-hidden">
                {/* --- Sidebar (Library) --- */}
                <div className="w-80 bg-gray-900 border-r border-gray-800 flex flex-col shrink-0">
                    <div className="p-4 border-b border-gray-800">
                        <h1 className="text-xl font-bold flex items-center gap-2 mb-4 text-blue-400">
                            <Icon name="book-open" size={24} /> 
                            AudioLibrary
                        </h1>
                        <div className="text-xs text-gray-500 mb-4">
                            Version {APP_VERSION}
                        </div>
                        
                        <div className="flex flex-col gap-2">
                            {/* Server Scan Button */}
                            <button 
                                onClick={scanServer}
                                className="flex items-center justify-center w-full px-4 py-2 bg-emerald-700 hover:bg-emerald-600 text-white rounded transition text-sm font-medium"
                            >
                                <Icon name="server" size={16} className="mr-2"/>
                                Scan Server (./books)
                            </button>

                            <div className="flex items-center gap-2 my-1">
                                <div className="h-px bg-gray-700 flex-1"></div>
                                <span className="text-xs text-gray-500">OR</span>
                                <div className="h-px bg-gray-700 flex-1"></div>
                            </div>

                            {/* Local File Input */}
                            <label className="flex items-center justify-center w-full px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-200 rounded cursor-pointer transition select-none text-sm">
                                <Icon name="folder-open" size={16} className="mr-2"/>
                                Browse Local Folder...
                                <input 
                                    type="file" 
                                    webkitdirectory="true" 
                                    directory="" 
                                    multiple 
                                    className="hidden" 
                                    onChange={handleFileSelect}
                                />
                            </label>
                        </div>
                    </div>

                    <div className="flex-1 overflow-y-auto p-2">
                        {loading && (
                            <div className="text-center p-4 text-gray-400">
                                <Icon name="loader-2" className="animate-spin mx-auto mb-2" />
                                Scanning...
                            </div>
                        )}
                        
                        {error && (
                            <div className="bg-red-900/50 border border-red-700 text-red-200 p-2 text-xs rounded mb-4">
                                {error}
                            </div>
                        )}

                        {!loading && Object.keys(books).length === 0 ? (
                            <div className="text-gray-500 text-center mt-10 p-4 text-sm">
                                <p>No books found yet.</p>
                                <p className="mt-2 text-xs opacity-60">
                                    For Server Mode: Ensure a "books" folder exists next to this file and "Directory Listing" is enabled on your server.
                                </p>
                            </div>
                        ) : (
                            Object.keys(books).map(book => (
                                <div key={book} className="mb-4">
                                    <h2 className="text-gray-400 text-sm uppercase font-bold px-2 mb-1 sticky top-0 bg-gray-900 py-1 z-10 border-b border-gray-800/50 flex justify-between">
                                        <span className="truncate">{book}</span>
                                        <span className="text-xs opacity-50 font-normal ml-2 mt-0.5">{books[book].length}</span>
                                    </h2>
                                    <div className="space-y-1">
                                        {books[book].map((track, idx) => (
                                            <button 
                                                key={`${book}-${idx}`}
                                                onClick={() => playTrack(book, idx)}
                                                className={`w-full text-left px-3 py-2 text-sm rounded truncate flex items-center gap-2 transition
                                                    ${currentBook === book && currentTrackIndex === idx 
                                                        ? 'bg-blue-900/50 text-blue-200 border-l-2 border-blue-500' 
                                                        : 'hover:bg-gray-800 text-gray-300'}`}
                                            >
                                                {currentBook === book && currentTrackIndex === idx && isPlaying ? (
                                                     <Icon name="volume-2" size={14} className="shrink-0" />
                                                ) : (
                                                     <span className="w-3.5 shrink-0"></span>
                                                )}
                                                <span className="truncate">{track.name}</span>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            ))
                        )}
                    </div>
                </div>

                {/* --- Main Content (Player) --- */}
                <div className="flex-1 flex flex-col bg-gray-950 relative overflow-hidden">
                    
                    {/* Visualizer Area */}
                    <div className="flex-1 flex items-center justify-center p-8 flex-col text-center z-0">
                        <div className="w-48 h-48 bg-gray-800 rounded-lg shadow-2xl flex items-center justify-center mb-6 border border-gray-700">
                             <Icon name="music" size={64} className="text-gray-600" />
                        </div>
                        <h2 className="text-2xl font-bold text-white mb-2 max-w-2xl truncate px-4">
                            {currentTrackName}
                        </h2>
                        <h3 className="text-lg text-gray-400 px-4">
                            {currentBook || "Select a book to start"}
                        </h3>
                        {sourceMode === 'server' && currentBook && (
                             <span className="mt-2 text-xs bg-emerald-900/50 text-emerald-400 px-2 py-0.5 rounded border border-emerald-800/50">Server Stream</span>
                        )}
                    </div>

                    {/* Controls Bar */}
                    <div className="bg-gray-900 border-t border-gray-800 p-6 pb-8 z-10">
                        
                        <div className="flex items-center gap-4 mb-4 text-sm text-gray-400 font-mono">
                            <span className="w-12 text-right">{formatTime(currentTime)}</span>
                            <input 
                                type="range" 
                                min="0" 
                                max={duration || 0} 
                                value={currentTime}
                                onChange={handleSeek}
                                className="flex-1 h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                            />
                            <span className="w-12">{formatTime(duration)}</span>
                        </div>

                        <div className="flex items-center justify-between">
                            
                            {/* Left: Sleep Timer */}
                            <div className="flex items-center gap-2 w-32">
                                <div className="relative group">
                                    <button className={`p-2 rounded-full hover:bg-gray-800 transition ${sleepTimerActive ? 'text-blue-400' : 'text-gray-400'}`}>
                                        <Icon name="clock" size={20} />
                                    </button>
                                    <div className="absolute bottom-full left-0 mb-2 w-40 bg-gray-800 rounded shadow-xl border border-gray-700 p-2 hidden group-hover:block z-10">
                                        <p className="text-xs text-center text-gray-400 mb-2 border-b border-gray-700 pb-1">Sleep Timer</p>
                                        <div className="space-y-1">
                                            <button onClick={() => activateSleepTimer(15)} className="w-full text-left text-xs p-1 hover:bg-gray-700 rounded text-gray-200">15 Minutes</button>
                                            <button onClick={() => activateSleepTimer(30)} className="w-full text-left text-xs p-1 hover:bg-gray-700 rounded text-gray-200">30 Minutes</button>
                                            <button onClick={cancelSleepTimer} className="w-full text-left text-xs p-1 hover:bg-red-900/50 rounded text-red-300">Off</button>
                                        </div>
                                    </div>
                                </div>
                                {sleepTimerActive && (
                                    <span className="text-xs text-blue-400 font-mono">
                                        {formatTime(sleepTimer/1000)}
                                    </span>
                                )}
                            </div>

                            {/* Center: Transport */}
                            <div className="flex items-center gap-6">
                                <button onClick={() => skip(-30)} className="text-gray-400 hover:text-white transition flex flex-col items-center group">
                                    <Icon name="rotate-ccw" size={24} />
                                    <span className="text-[10px] text-gray-600 group-hover:text-gray-400">-30s</span>
                                </button>

                                <button 
                                    onClick={togglePlay} 
                                    className="w-14 h-14 bg-blue-600 hover:bg-blue-500 rounded-full flex items-center justify-center text-white shadow-lg shadow-blue-900/50 transition transform hover:scale-105"
                                >
                                    {isPlaying ? <Icon name="pause" size={28} fill="white" /> : <Icon name="play" size={28} fill="white" className="ml-1" />}
                                </button>

                                <button onClick={() => skip(30)} className="text-gray-400 hover:text-white transition flex flex-col items-center group">
                                    <Icon name="rotate-cw" size={24} />
                                    <span className="text-[10px] text-gray-600 group-hover:text-gray-400">+30s</span>
                                </button>
                            </div>

                            {/* Right: Playback Rate */}
                            <div className="flex items-center gap-2 w-32 justify-end">
                                <button 
                                    className="text-xs font-bold text-gray-400 hover:text-white border border-gray-700 px-2 py-1 rounded"
                                    onClick={() => {
                                        const newRate = playbackRate === 1 ? 1.25 : playbackRate === 1.25 ? 1.5 : playbackRate === 1.5 ? 2.0 : 1.0;
                                        setPlaybackRate(newRate);
                                        if(audioRef.current) audioRef.current.playbackRate = newRate;
                                    }}
                                >
                                    {playbackRate}x
                                </button>
                            </div>

                        </div>
                    </div>

                    {/* Debug Panel */}
                    <div className="border-t border-gray-800 bg-gray-950 px-6 py-4 text-xs text-gray-400 max-h-40 overflow-y-auto">
                        <div className="flex items-center justify-between mb-2">
                            <span className="uppercase tracking-wide text-gray-500">Diagnostics</span>
                            <button
                                className="text-xs text-gray-500 hover:text-gray-300"
                                onClick={() => setDebugLog([])}
                            >
                                Clear
                            </button>
                        </div>
                        {debugLog.length === 0 ? (
                            <div className="text-gray-600">No diagnostics yet. Click a track to capture logs.</div>
                        ) : (
                            <ul className="space-y-1 font-mono">
                                {debugLog.map((line, idx) => (
                                    <li key={`${line}-${idx}`}>{line}</li>
                                ))}
                            </ul>
                        )}
                    </div>
                </div>

                <audio ref={audioRef} />
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

</script>
</body>
</html>
